#import "lib/definitions.typ": *

== 하이퍼뷰: 모바일 하이퍼미디어

하이퍼미디어 아키텍처가 웹, 웹 브라우저 및 HTML과 동의어로 여겨져도 괜찮습니다. 웹은 가장 큰 하이퍼미디어 시스템이며, 웹 브라우저는 가장 인기 있는 하이퍼미디어 클라이언트입니다. 하이퍼미디어에 대한 논의에서 웹이 지배적이기 때문에 하이퍼미디어가 일반적인 개념이라는 것을 잊기 쉽고, 모든 유형의 플랫폼과 애플리케이션에 적용될 수 있습니다. 이 장에서는 비웹 플랫폼인 네이티브 모바일 애플리케이션에 하이퍼미디어 아키텍처가 어떻게 적용되는지 살펴보겠습니다.

모바일 플랫폼은 웹과는 다른 제약을 가지고 있습니다. 모바일은 다른 거래와 디자인 결정을 요구합니다. 그럼에도 불구하고 하이퍼미디어, HATEOAS 및 REST의 개념은 매력적인 모바일 애플리케이션을 구축하는 데 직접적으로 적용될 수 있습니다.

이 장에서는 현재 모바일 앱 개발의 단점을 다루고, 하이퍼미디어 아키텍처가 이러한 문제를 어떻게 해결할 수 있는지를 살펴보겠습니다. 그런 다음 모바일에서 하이퍼미디어로 나아가는 경로인 하이퍼뷰(Hyperview)를 살펴볼 것입니다. 하이퍼뷰는 하이퍼미디어 아키텍처를 사용하는 모바일 앱 프레임워크입니다. 마지막으로 하이퍼뷰에서 사용하는 하이퍼미디어 형식인 HXML에 대한 개요로 마무리하겠습니다.

=== 모바일 앱 개발의 현황 <_the_state_of_mobile_app_development>
모바일 플랫폼에 하이퍼미디어를 적용하는 방법을 논의하기 전에, 네이티브 모바일 앱이 일반적으로 어떻게 구축되는지를 이해해야 합니다. 저는 "네이티브"라는 단어를 전화의 운영 체제(일반적으로 Android 또는 iOS)에서 제공하는 SDK에 대해 작성된 코드를 지칭하는 데 사용하고 있습니다. 이 코드는 실행 가능한 바이너리로 패키징되어 Google과 Apple이 관리하는 앱 스토어를 통해 업로드되고 승인됩니다. 사용자가 앱을 설치하거나 업데이트하면, 그들은 이 실행 파일을 다운로드하고 자신의 장치의 운영 체제에서 직접 코드를 실행합니다. 이러한 방식으로, 모바일 앱은 예전의 Mac, Windows 또는 Linux용 데스크톱 앱과 많은 공통점을 가지고 있습니다. 그러나 오늘날의 모바일 앱과 과거의 PC 데스크톱 앱 간에는 한 가지 중요한 차이점이 있습니다. 요즘의 모바일 앱은 거의 모두 "네트워크화"되어 있습니다. 네트워크화된 앱은 핵심 기능을 제공하기 위해 인터넷을 통해 데이터를 읽고 쓸 필요가 있습니다. 즉, 네트워크화된 모바일 앱은 클라이언트-서버 아키텍처를 구현해야 합니다.

클라이언트-서버 아키텍처를 구현할 때, 개발자는 결정을 내려야 합니다: 앱을 얇은 클라이언트(thin client)로 설계할 것인가, 두꺼운 클라이언트(thick client)로 설계할 것인가? 현재 모바일 생태계는 개발자를 두꺼운 클라이언트 접근 방식으로 강하게 끌어옵니다. 그 이유는 무엇일까요? Android와 iOS는 네이티브 모바일 앱이 실행 가능한 바이너로 패키징되고 배포되어야 한다고 요구합니다. 그럴 수 있는 방법은 없습니다. 개발자는 실행 파일에 패키징하기 위해 코드를 작성해야 하므로, 그 코드에서 앱의 일부 로직을 구현하는 것이 논리적으로 보입니다. 코드는 서버에 HTTP 호출을 초기화하여 데이터를 검색하고, 그런 다음 해당 데이터를 플랫폼의 UI 라이브러리를 사용하여 렌더링할 수 있습니다. 따라서 개발자는 자연스럽게 다음과 같은 두꺼운 클라이언트 패턴으로 이끌립니다:
- 클라이언트는 서버에 API 요청을 하기 위한 코드와 해당 응답을 UI 업데이트로 변환하는 코드를 포함합니다.
- 서버는 JSON를 사용하는 HTTP API를 구현하며 클라이언트의 상태에 대해 거의 알지 못합니다.

웹의 SPA와 마찬가지로, 이 아키텍처에는 큰 단점이 있습니다: 앱의 로직이 클라이언트와 서버에 분산되어 있습니다. 때로는 이 로직이 중복될 수 있습니다(예: 폼 데이터를 검증하기 위해). 다른 경우에는 클라이언트와 서버 각각이 앱의 전체 로직의 불연속적인 부분을 구현합니다. 앱이 무엇을 하는지 이해하려면, 개발자는 두 가지 매우 다른 코드베이스 간의 상호 작용을 추적해야 합니다.

또한 모바일 앱에 더 많은 영향을 미치는 또 다른 단점은 API 변화(API churn)입니다. 앱 스토어는 앱의 배포 및 업데이트 방식을 제어합니다. 사용자는 업데이트된 버전을 받을지 여부와 시기를 조절할 수 있습니다. 모바일 개발자로서 모든 사용자가 앱의 최신 버전을 사용하고 있다고 가정할 수 없습니다. 프론트엔드 코드는 많은 버전으로 분산되고, 이제 백엔드는 모든 버전을 지원해야 합니다.

=== 모바일 앱을 위한 하이퍼미디어

#index[hypermedia][for mobile]
하이퍼미디어 아키텍처가 웹의 SPA의 단점을 해결할 수 있다는 것을 이미 보았습니다. 하지만 하이퍼미디어가 모바일 앱에서도 작동할 수 있을까요? 대답은 Yes입니다!

웹에서와 마찬가지로 모바일에서도 하이퍼미디어 형식을 사용하여 애플리케이션 상태의 엔진으로 사용할 수 있습니다. 모든 로직은 두 개의 코드베이스에 분산되는 것이 아니라 백엔드에서 제어됩니다. 하이퍼미디어 아키텍처는 모바일 앱의 API 변화 문제 또한 해결합니다. 백엔드가 데이터와 액션을 포함하는 하이퍼미디어 응답을 제공하므로 데이터와 UI가 동기화되지 않는 문제는 없습니다. 더 이상 하위 호환성이나 여러 API 버전을 유지하는 것에 대한 걱정이 아닙니다.

그렇다면 모바일 앱에 하이퍼미디어를 어떻게 사용할 수 있을까요? 현재 네이티브 모바일 앱을 구축하고 공급하기 위해 두 가지 접근 방식이 있습니다:
- 웹 뷰(Web views): 신뢰할 수 있는 웹 플랫폼을 모바일 앱 껍데기로 감싸는 것
- 하이퍼뷰(Hyperview): 모바일 앱을 위해 특별히 설계된 새로운 하이퍼미디어 시스템

==== 웹 뷰 <_web_views>
모바일에서 하이퍼미디어 아키텍처를 사용하는 가장 간단한 방법은 웹 기술을 활용하는 것입니다. Android와 iOS SDK 모두 "웹 뷰"를 제공합니다: 네이티브 앱 내에 삽입할 수 있는 크롬 없는 웹 브라우저입니다. Apache Cordova와 같은 도구를 사용하면 웹 사이트의 URL을 가져와 웹 뷰를 기반으로 하는 네이티브 iOS 및 Android 앱을 쉽게 생성할 수 있습니다. 이미 반응형 웹 앱이 있다면, "네이티브" 모바일 HDA를 무료로 얻을 수 있습니다. 너무 좋게 들리죠, 맞죠?

물론 이 접근 방식에는 근본적인 제한이 있습니다. 웹 플랫폼과 모바일 플랫폼은 서로 다른 기능과 UX 규칙을 가지고 있습니다. HTML은 모바일 앱의 일반적인 UI 패턴을 자연스럽게 지원하지 않습니다. 가장 큰 차이점 중 하나는 각 플랫폼에서 네비게이션을 처리하는 방식입니다. 웹에서 네비게이션은 페이지 기반으로, 한 페이지가 다른 페이지를 대체하며 브라우저가 페이지 히스토리를 탐색할 수 있도록 뒤로/앞으로 버튼을 제공합니다. 모바일에서는 네비게이션이 더 복잡하며 제스처 기반 상호작용의 물리성에 맞게 조정됩니다.
- 세부적인 내용을 파고들면, 화면은 서로 위로 슬라이드하여 화면의 스택을 형성합니다.
- 앱의 상단 또는 하단에 있는 탭 바를 통해 다양한 화면 스택 간에 전환할 수 있습니다.
- 모달은 앱의 하단에서 위로 슬라이드 하여 다른 스택과 탭 바를 가립니다.
- 웹 페이지와는 달리, 모든 이러한 화면은 여전히 메모리에 존재하며, 앱 상태에 따라 렌더링되고 업데이트됩니다.

네비게이션 아키텍처는 모바일과 웹 앱이 작동하는 방식 간의 주요 차이점입니다. 그러나 그것이 유일한 차이점은 아닙니다. 모바일 앱에 존재하지만 웹에서 원래 지원되지 않는 많은 다른 UX 패턴이 있습니다:
- 화면의 내용을 새로고침하는 풀 투 리프레시
- UI 요소에 대한 수평 스와이프를 통해 액션을 드러내기
- 고정 헤더가 있는 분메이션 목록

이러한 상호작용은 웹 브라우저에서 원래 지원되지 않지만, JS 라이브러리를 통해 시뮬레이션할 수 있습니다. 물론 이러한 라이브러리는 네이티브 제스처와 같은 느낌과 성능을 얻을 수는 없습니다. 또한 이를 사용하려면 일반적으로 React와 같은 JS 중심 SPA 아키텍처를 수용해야 합니다. 이는 우리를 다시 원점으로 되돌립니다! 네이티브 모바일 앱의 전형적인 두꺼운 클라이언트 아키텍처를 사용하지 않기 위해 우리는 웹 뷰로 눈을 돌렸습니다. 웹 뷰는 우리가 하이퍼미디어 기반 HTML을 사용할 수 있게 합니다. 하지만 모바일 앱의 원하는 모양과 느낌을 얻으려면, 우리는 JS로 SPA를 구축하게 되어 하이퍼미디어의 이점을 잃게 됩니다.

네이티브 앱처럼 작동하고 느껴지는 모바일 HDA를 구축하기 위해서는 HTML로는 충분하지 않습니다. 우리는 네이티브 모바일 앱의 상호작용과 패턴을 표현하기 위해 설계된 형식이 필요합니다. 그것이 바로 하이퍼뷰(Hyperview)가 하는 일입니다.

==== 하이퍼뷰

#indexed[Hyperview]는 다음을 제공하는 오픈 소스 하이퍼미디어 시스템입니다:
- 모바일 앱을 정의하기 위한 하이퍼미디어 형식인 HXML
- iOS 및 Android에서 작동하는 HXML을 위한 하이퍼미디어 클라이언트
- 주어진 앱을 위해 프레임워크를 사용자화할 수 있는 HXML 및 클라이언트의 확장 포인트

===== 형식

#indexed[HXML]은 HTML 작업에 익숙한 웹 개발자들에게 친숙하게 느껴지도록 설계되었습니다. 따라서 기본 형식으로 XML을 선택했습니다. 친숙한 수리학 외에도 XML은 서버 측 렌더링 라이브러리와 호환됩니다. 예를 들어 Jinja2는 HXML을 렌더링할 수 있는 템플릿 라이브러리로 적합합니다. XML의 친숙함과 백엔드 통합의 용이성 덕분에 새 코드베이스와 기존 코드베이스 모두에서 쉽게 채택할 수 있습니다. HXML로 작성된 "Hello World" 앱을 살펴보세요. 구문은 HTML 작업을 해본 사람에게는 익숙할 것입니다.

#figure(caption: [Hello World])[
```xml
<doc xmlns="https://hyperview.org/hyperview">
  <screen>
    <styles />
    <body>
      <header>
        <text>My first app</text>
      </header>
      <view>
        <text>Hello World!</text>
      </view>
    </body>
  </screen>
</doc>
``` ]

그러나 HXML은 이름이 다른 태그로 HTML을 단순히 포팅한 것이 아닙니다. 이전 장에서는 htmx가 HTML을 새로운 속성의 집합으로 향상시키는 방법을 살펴보았습니다. 이러한 추가는 HTML의 선언적 특성을 유지하면서 개발자가 풍부한 웹 앱을 생성할 수 있는 힘을 부여합니다. HXML에서는 htmx의 개념이 사양에 내장되어 있습니다. 특히 HXML은 기본 HTML과 같은 "링크 클릭"과 "폼 제출" 상호작용으로 제한되지 않습니다. HXML은 화면의 내용을 수정하기 위한 다양한 트리거와 액션을 지원합니다. 이러한 상호작용은 "행동"이라는 강력한 개념으로 묶입니다. 개발자는 스크립팅 없이도 앱에 새로운 기능을 추가하기 위해 새로운 행동 액션을 정의할 수 있습니다. 우리는 이 장에서 후에 행동에 대해 더 알아볼 것입니다.

===== 클라이언트

#index[hypermedia][client]
하이퍼뷰는 React Native로 작성된 오픈 소스 HXML 클라이언트 라이브러리를 제공합니다. 약간의 설정과 몇 가지 명령어를 통해 이 라이브러리는 iOS 또는 Android용 네이티브 앱 바이너리로 컴파일됩니다. 사용자는 앱 스토어를 통해 기기에 앱을 설치합니다. 시작하면, 앱은 구성된 URL에 HTTP 요청을 하고 HXML 응답을 첫 번째 화면으로 렌더링합니다.

하이퍼뷰를 사용하여 HDA를 개발하는 데 특수 목적의 클라이언트 바이너리가 필요하다고 하는 것이 조금 이상하게 보일 수 있습니다. 결국 우리는 사용자가 웹 앱을 보려면 먼저 바이너리를 다운로드하고 설치하도록 요청하지 않습니다. 아니요, 사용자는 일반-purpose 웹 브라우저의 주소 표시줄에 URL을 입력합니다. 하나의 HTML 클라이언트가 모든 HTML 서버에서 앱을 렌더링합니다(@fig-1clientmanyserver).

#asciiart(
  read("images/diagram/one-client-many-servers.txt"), caption: [하나의 HTML 클라이언트, 여러 HTML 서버],
)<fig-1clientmanyserver>

이론적으로 말하자면, 등가의 일반-purpose "하이퍼뷰 브라우저"를 구축하는 것이 가능합니다. 이 HXML 클라이언트는 모든 HXML 서버로부터 앱을 렌더링하고 사용자는 사용하고자 하는 앱을 지정하기 위해 URL을 입력합니다. 그러나 iOS와 Android는 단일 목적 앱의 개념을 기준으로 설계되었습니다. 사용자는 앱 스토어에서 앱을 찾아 설치하고, 장치의 홈 화면에서 이를 실행하기를 기대합니다. 하이퍼뷰는 오늘날의 인기 모바일 플랫폼의 앱 중심 패러다임을 수용합니다. 이는 HXML 클라이언트(앱 바이너리)가 단일 사전 구성된 HXML 서버(@fig-1client1server)로부터 UI를 렌더링 함을 의미합니다.

#asciiart(
  read("images/diagram/one-server-one-hxml-client.txt"), caption: [하나의 HXML 클라이언트, 하나의 HXML 서버],
)<fig-1client1server>

다행히도 개발자는 처음부터 HXML 클라이언트를 작성할 필요는 없습니다. 오픈 소스 클라이언트 라이브러리가 99%의 일을 수행합니다. 그리고 다음 섹션에서 볼 수 있듯이, HDA에서 클라이언트와 서버를 모두 제어하는 것은 주요 이점을 가지고 있습니다.

===== 확장성 <_extensibility>
하이퍼뷰 아키텍처의 이점을 이해하기 위해, 먼저 웹 아키텍처의 단점을 논의해야 합니다. 웹에서는 모든 웹 브라우저가 모든 웹 서버의 HTML을 렌더링할 수 있습니다. 이 수준의 호환성은 HTML5와 같은 잘 정의된 표준이 있어야만 발생할 수 있습니다. 그러나 표준을 정의하고 발전시키는 것은 수고로운 과정입니다. 예를 들어, W3C는 HTML5 사양에 대해 첫 제안에서 추천에 이르기까지 7년 이상 걸렸습니다. 이는 많은 사람들에게 영향을 미치는 변경사항에 관한 깊은 사고가 필요하기 때문에 놀라운 일이 아닙니다. 그러나 이는 진전이 느리게 진행된다는 것을 의미합니다. 웹 개발자는 필요로 하는 기능에 대해 브라우저가 널리 지원되기를 기다려야 할 수 있습니다.

그렇다면 하이퍼뷰 아키텍처의 이점은 무엇일까요? 하이퍼뷰 앱에서는 _귀하의_ 모바일 앱이 _귀하의_ 서버에서만 HXML을 렌더링합니다. 이를 통해 서버와 다른 모바일 앱 간, 또는 모바일 앱과 다른 서버 간의 호환성에 대한 걱정할 필요가 없습니다. 상담할 표준 기관도 없습니다. 모바일 앱에 반짝이는 기능을 추가하고 싶다면, 클라이언트에서 `<blink>` 요소를 구현하고, 서버에서 HXML 응답으로 `<blink>` 요소를 반환하기만 하면 됩니다. 실제로 하이퍼뷰 클라이언트 라이브러리는 이러한 유형의 확장성을 염두에 두고 구축되었습니다. 사용자 정의 UI 요소와 사용자 정의 행동 작업을 위한 확장 포인트가 있습니다. 우리는 개발자들이 이러한 확장을 사용하여 HXML을 앱의 기능에 맞게 보다 표현력 있고 맞춤형으로 만드는 것을 기대하고 장려합니다.

그리고 HXML 형식과 클라이언트 자체를 확장함으로써, 하이퍼뷰 HXML에 스크립팅 레이어를 포함할 필요는 없습니다. 클라이언트 측 로직이 필요한 기능은 클라이언트 바이너리에 "내장"됩니다. HXML 응답은 순수하게 유지되며, UI 및 상호작용은 선언적 XML로 표현됩니다.

==== 어떤 하이퍼미디어 아키텍처를 사용해야 할까요? <_which_hypermedia_architecture_should_you_use>
하이퍼미디어 시스템을 사용한 모바일 앱 생성에 대한 두 가지 접근 방식을 논의했습니다:
- HTML을 반환하는 백엔드를 만들고 모바일 앱을 웹 뷰를 통해 제공
- HXML을 반환하는 백엔드를 만들고 Hyperview 클라이언트를 통해 모바일 앱을 제공

저는 두 가지 접근 방식을 강조하기 위해 의도적으로서 비슷한 방식을 설명했습니다. 결국, 이들은 모두 하이퍼미디어 시스템을 기반으로 하지만 서로 다른 형식과 클라이언트를 가지고 있습니다. 두 접근 모두 전통적인 SPA 유사한 모바일 앱 개발의 근본적인 문제를 해결합니다:
- 백엔드는 앱의 전체 상태를 제어합니다.
- 우리의 앱 로직은 한 곳에 모여 있습니다.
- 앱은 항상 최신 버전을 실행하며, 걱정할 API 변화가 없습니다.

그렇다면 모바일 HDA에 어떤 접근 방식을 사용해야 할까요? 두 가지 유형의 앱 모두를 구축한 우리의 경험을 바탕으로, 우리는 하이퍼뷰 접근 방식이 더 나은 사용자 경험을 가져온다고 믿습니다. 웹 뷰는 iOS 및 Android에서 항상 부적절하게 느껴질 것입니다. 모바일 사용자가 기대하는 네비게이션 및 상호작용 패턴을 복제하는 데는 좋은 방법이 없습니다. 하이퍼뷰는 두꺼운 클라이언트와 웹 뷰 접근 방식의 한계를 해결하기 위해 특별히 만들어졌습니다. 하이퍼뷰를 배우기 위한 초기 투자 후에는 하이퍼미디어 아키텍처의 모든 이점을 얻으면서 사용자 경험 열화의 단점은 피할 수 있습니다.

물론 이미 간단하게 모바일 친화적인 웹 앱이 있다면, 웹 뷰 접근 방식을 사용하면 합리적입니다. HTML 외에도 HXML으로 앱을 제공해야 하는 수고를 덜어주기 때문에 확실히 시간을 절약할 수 있습니다. 그러나 이 장의 끝에서 보여드리겠지만, 기존 하이퍼미디어 기반 웹 앱을 하이퍼뷰 모바일 앱으로 변환하는 데 많은 작업이 필요하지 않습니다. 그러나 그 전에 우리는 하이퍼뷰의 요소 및 행동 개념을 소개해야 합니다. 그런 다음, 하이퍼뷰에서 우리의 연락처 앱을 다시 구축할 것입니다.

#sidebar[하이퍼미디어를 사용하여 모바일 앱을 구축하지 말아야 할 때는?][ 하이퍼미디어는 모바일 앱을 구축하는 데 항상 올바른 선택은 아닙니다. 웹과 마찬가지로, 고도로 동적인 UI(예: 스프레드시트 애플리케이션)를 요구하는 앱은 클라이언트 측 코드로 구현하는 것이 좋습니다. 또한 일부 앱은 완전히 오프라인 상태에서 작동해야 합니다. HDAs는 UI를 렌더링하기 위해 서버가 필요하기 때문에 오프라인 우선 모바일 앱과는 적합하지 않습니다. 그러나 웹과 마찬가지로 개발자는 하이브리드 접근 방식을 사용하여 모바일 앱을 구축할 수 있습니다. 매우 동적인 화면은 복잡한 클라이언트 측 로직으로 구축하고, 덜 동적인 화면은 웹 뷰나 하이퍼뷰로 구축할 수 있습니다. 이처럼 개발자는 애플리케이션의 _복잡성 예산_을 핵심에 집중하고, 단순한 화면은 단순하게 유지할 수 있습니다. ]

=== HXML 소개

==== 헬로 월드!

#index[HXML][Hello World!]
HXML은 HTML에서 오는 웹 개발자들에게 자연스럽게 느껴지도록 설계되었습니다. HXML에서 정의된 "Hello World" 앱을 살펴보겠습니다:

#figure(caption: [Hello World, revisited])[ ```xml
<doc xmlns="https://hyperview.org/hyperview"> <1>
  <screen> <2>
    <styles />
    <body> <3>
      <header> <4>
        <text>My first app</text>
      </header>
      <view> <5>
        <text>Hello World!</text> <6>
      </view>
    </body>
  </screen>
</doc>
``` ]
1. HXML 앱의 루트 요소
2. 앱의 화면을 나타내는 요소
3. 화면의 UI를 나타내는 요소
4. 화면의 상단 헤더를 나타내는 요소
5. 화면에 표시되는 콘텐츠를 감싸는 요소
6. 화면에 표시되는 텍스트 콘텐츠

여기에는 의외의 것이 없죠? HTML과 마찬가지로, 구문은 시작 태그(`<screen>`)와 종료 태그(`</screen>`)를 사용하여 요소의 트리를 정의합니다. 요소는 다른 요소(`<view>`)나 텍스트(`Hello World!`)를 포함할 수 있습니다. 요소는 빈 상태로 존재할 수 있으며, 빈 태그(`<styles />`)로 표현됩니다. 그러나 HXML 요소의 이름은 HTML의 이름과 다르다는 점을 주목해야 합니다. 각 요소가 무엇을 하는지 이해하기 위해 해당 요소를 좀 더 자세히 살펴보겠습니다.

#index[HXML][\<doc\>]
`<doc>`는 HXML 앱의 루트입니다. HTML의 `<html>` 요소에 해당한다고 생각하면 됩니다. `<doc>` 요소에는 속성 `xmlns="https://hyperview.org/hyperview"`가 포함되어 있습니다. 이는 문서의 기본 이름공간을 정의합니다. 이름공간은 서로 다른 개발자가 정의한 요소를 포함하는 문서를 만드는 XML의 기능입니다. 두 개발자가 동일한 이름을 가진 요소를 사용하려고 할 때 충돌을 방지하기 위해 각 개발자는 고유한 이름공간을 정의합니다. 사용자 정의 요소 및 행동에 대해 논의할 때 이름공간에 대해 더 이야기하겠습니다. 지금은 HXML 문서에서 이름공간이 명시적으로 없으면 요소가 `https://hyperview.org/hyperview` 이름공간의 일부로 간주된다는 것을 아는 것으로 충분합니다.

#index[HXML][\<screen\>]
`<screen>`은 모바일 앱의 단일 화면에서 렌더링되는 UI를 나타냅니다. 하나의 `<doc>`에는 여러 `<screen>` 요소가 포함될 수 있지만, 지금은 그 부분을 두지 않겠습니다. 일반적으로 `<screen>` 요소는 화면의 콘텐츠와 스타일을 정의하는 요소를 포함합니다.

#index[HXML][\<styles\>]
`<styles>`는 화면에서의 UI 스타일을 정의합니다. 이 장에서는 하이퍼뷰에서 스타일링에 대해 많이 다루지는 않을 것입니다. HXML에서는 HTML과 달리 스타일을 정의하기 위해 별도의 언어(CSS)를 사용하지 않습니다. 대신, 색상, 간격, 레이아웃, 글꼴과 같은 스타일링 규칙이 HXML에 정의됩니다. 이 규칙은 CSS의 클래스를 사용하는 것처럼 UI 요소에서 명시적으로 참조됩니다.

#index[HXML][\<body\>]
`<body>`는 화면의 실제 UI를 정의합니다. 본문에는 사용자에게 표시될 모든 텍스트, 이미지, 버튼, 폼 등이 포함됩니다. 이는 HTML의 `<body>` 요소에 해당합니다.

#index[HXML][\<header\>]
`<header>`는 화면의 헤더를 정의합니다. 일반적으로 모바일 앱의 헤더는 일부 내비게이션(예: 뒤로 버튼)과 화면의 제목을 포함합니다. 헤더를 본문의 나머지 부분과 별도로 정의하는 것이 유용합니다. 일부 모바일 운영 체제는 헤더와 화면 콘텐츠의 전환 방식이 다를 수 있습니다.

#index[HXML][\<view\>]
`<view>`는 화면 본문의 레이아웃과 구조를 위한 기본 요소입니다. HTML의 `<div>`와 같은 개념으로 생각하면 됩니다. HTML과는 달리 `<div>`는 직접적으로 텍스트를 포함할 수 없습니다.

#index[HXML][\<text\>]
`<text>` 요소는 UI에서 텍스트를 렌더링하는 유일한 방법입니다. 이 예제에서 "Hello World"는 `<text>` 요소 안에 포함되어 있습니다.

이것이 HXML에서 기본 "Hello World" 앱을 정의하는 모든 것입니다. 물론, 이는 그다지 흥미롭지 않습니다. 다른 내장 표시 요소를 다뤄보겠습니다.

==== UI 요소

===== 목록

#index[HXML][\<list\>]
#index[HXML][\<item\>]
모바일 앱에서 매우 일반적인 패턴은 항목 목록을 스크롤하는 것입니다. 전화 화면의 물리적 속성(길고 세로형)과 손가락을 위아래로 스와이프하는 직관적인 제스처가 이를 많은 화면에 적합한 선택이 되게 합니다.

HXML은 목록과 항목을 나타내기 위한 전용 요소를 가지고 있습니다.

#figure(caption: [목록 요소])[ ```xml
<list> <1>
  <item key="item1"> <2>
    <text>My first item</text> <3>
  </item>
  <item key="item2">
    <text>My second item</text>
  </item>
</list>
``` ]
1. 목록을 나타내는 요소
2. 목록의 항목을 나타내는 요소, 고유한 키 포함
3. 목록에 있는 항목의 콘텐츠.

목록은 두 개의 새 요소로 표현됩니다. `<list>`는 목록의 모든 요소를 감싸고 있습니다. 이는 일반적인 `<view>`처럼 스타일을 적용할 수 있습니다(너비, 높이 등). `<list>` 요소는 `<item>` 요소만 포함합니다. 물론 이들은 목록에서 각각 고유한 항목을 나타냅니다. `<item>`은 고유한 `key` 속성을 가져야 하며, 이는 목록의 모든 항목 사이에서 유일해야 합니다.

"왜 항목 목록에 대한 사용자 정의 구문이 필요할까요? 그냥 많은 `<view>` 요소를 사용할 수는 없나요?"라는 질문이 있을 수 있습니다. 네, 항목 수가 적은 목록의 경우 중첩된 `<view>`를 사용하는 것이 잘 작동할 것입니다. 그러나 목록의 항목 수가 충분히 길어지면 부드러운 스크롤 상호작용을 지원하기 위한 최적화가 필요할 수 있습니다. 예를 들어, 소셜 미디어 앱의 게시물 피드를 탐색한다고 가정해 보십시오. 사용자가 피드를 스크롤할 때, 앱이 수백 개에 이르는 게시물을 보여주는 것은 드문 일이 아닙니다. 언제든지 손가락을 휙 움직여 피드의 거의 어떤 부분으로도 스크롤할 수 있습니다. 모바일 장치는 일반적으로 메모리 제약이 있습니다. 메모리에 렌더링된 항목 목록을 모두 보존하는 것은 가용 자원을 초과할 수 있습니다. 그래서 iOS와 Android는 최적화된 목록 UI에 대한 API를 제공합니다. 이 API는 현재 화면에 표시되는 목록의 부분을 알고 있습니다. 메모리를 절약하기 위해 표시되지 않는 목록 항목을 클리어하고, 메모리를 절약하기 위해 항목 UI 객체를 재활용합니다. HXML에서 명시적인 `<list>` 및 `<item>` 요소를 사용함으로써, 하이퍼뷰 클라이언트는 이러한 최적화된 목록 API를 사용하여 앱의 성능을 보다 높일 수 있습니다.

#index[HXML][\<section\>]
#index[HXML][\<section-list\>]
#index[HXML][\<section-title\>]
HXML은 섹션 리스트도 지원합니다. 섹션 리스트는 목록 기반 UI를 구축하는 데 유용하며, 목록의 항목을 사용자의 편의를 위해 그룹화할 수 있습니다. 예를 들어, 레스토랑 메뉴를 표시하는 UI가 접시 종류별로 제공할 수 있습니다:

#figure(caption: [섹션 목록 요소])[ ```xml
<section-list> <1>
  <section> <2>
    <section-title> <3>
      <text>Appetizers</text>
    </section-title>
    <item key="1"> <4>
      <text>French Fries</text>
    </item>
    <item key="2">
      <text>Onion Rings</text>
    </item>
  </section>

  <section> <5>
    <section-title>
      <text>Entrees</text>
    </section-title>
    <item key="3">
      <text>Burger</text>
    </item>
  </section>
</section-list>
``` ]
1. 섹션을 포함하는 목록을 나타내는 요소
2. 애피타이저 제공을 위한 첫 번째 섹션
3. 섹션의 제목을 위한 요소, "Appetizers"라는 텍스트를 렌더링
4. 애피타이저를 나타내는 항목
5. 앙트레 제공을 위한 섹션

`<list>`와 `<section-list>` 간의 몇 가지 차이점을 볼 수 있습니다. 섹션 목록 요소는 고유한 항목을 나타내는 `<section>` 요소만 포함합니다. 섹션은 `<section-title>` 요소를 포함할 수 있습니다. 이는 섹션의 헤더로 작용하는 UI를 렌더링하는 데 사용됩니다. 이 헤더는 스크롤하면서 항목을 탐색할 때 화면에 유지됩니다. 마지막으로, `<item>` 요소는 일반 목록에서처럼 작동합니다. 하지만 `<section>` 내에서만 나타날 수 있습니다.

===== 이미지

#index[HXML][\<image\>]
#index[Hyperview][images]
하이퍼뷰에서 이미지를 표시하는 것은 HTML과 매우 유사하지만 몇 가지 차이가 있습니다.

#figure(caption: [이미지 요소])[ ```xml
<image source="/profiles/1.jpg" style="avatar" />
``` ]

`source` 속성은 이미지를 로드하는 방법을 지정합니다. HTML과 마찬가지로, 소스는 절대 또는 상대 URL이 될 수 있습니다. 또한, 소스는 인코딩된 데이터 URI일 수 있습니다(예: `data:image/png;base64,iVBORw`). 그러나 소스는 모바일 앱의 자산으로 번들된 이미지를 참조하는 "로컬" URL일 수도 있습니다. 로컬 URL는 `./`를 접두사로 가집니다:

#figure(caption: [로컬 소스를 가리키는 이미지 요소])[ ```xml
<image source="./logo.png" style="logo" />
``` ]

로컬 URL를 사용하는 것은 최적화입니다. 이미지는 모바일 장치에 있기 때문에 네트워크 요청이 필요하지 않고 즉시 나타납니다. 그러나 이미지를 모바일 앱 바이너리에 번들하면 바이너리 크기가 증가합니다. 자주 접근하지만 변경 빈도가 낮은 이미지(예: 앱 로고, 일반 버튼 아이콘)는 로컬 이미지를 사용하는 것이 좋은 거래입니다.

또한 HXML의 `<image>` 요소에 `style` 속성이 존재하는 점에 주목해야 합니다. HXML에서는 이미지에 대해 `width` 및 `height`에 대한 규칙이 있는 스타일을 가져야 합니다. 이는 HTML과 달리 `<img>` 요소는 넓이와 높이를 명시적으로 설정할 필요가 없습니다. 웹 브라우저는 이미지를 가져오고 그 크기가 알려진 후 페이지의 콘텐츠를 다시 흐르게 합니다. 콘텐츠를 다시 흐르게 하는 것은 웹 기반 문서에서는 합리적인 동작이지만, 사용자는 모바일 앱이 콘텐츠가 로드되는 동안 다시 흐르게 되기를 기대하지 않습니다. 고정 레이아웃을 유지하기 위해서는 HXML에서 이미지가 로드되기 전에 크기를 알고 있어야 합니다.

==== 입력

#index[Hyperview][inputs]
하이퍼뷰에서 입력에 대해 다룰 내용이 많습니다. 이는 소개용으로 작성된 것이고 포괄적이지 않기 때문에 몇 가지 입력 유형만 강조하겠습니다. 먼저, 가장 간단한 입력 유형인 텍스트 필드를 예로 들겠습니다.

#figure(caption: [텍스트 필드 요소])[ ```xml
<text-field
  name="first_name" <1>
  style="input" <2>
  value="Adam" <3>
  placeholder="First name" <4>
/>
``` ]
1. 이 입력으로부터 데이터를 직렬화할 때 사용되는 이름
2. UI 요소에 적용되는 스타일 클래스
3. 필드에 설정된 현재 값
4. 값이 비어 있을 때 표시할 자리 표시자

#index[HXML][\<text-field\>]
이 요소는 HTML에서 텍스트 필드를 만든 적이 있는 사람에게는 익숙할 것입니다. 한 가지 차이점은 HTML의 대부분 입력이 `type` 속성을 가진 `<input>` 요소를 사용한다는 것입니다(예: `<input type="text">`). 하이퍼뷰에서는 각 입력이 고유한 이름을 가집니다. 이 경우 `<text-field>`입니다. 서로 다른 이름을 사용함으로써, 입력을 표현하기 위해 더 표현력 있는 XML을 사용할 수 있습니다.

예를 들어, 사용자가 여러 옵션 중 하나를 선택할 수 있도록 하는 UI를 렌더링하려고 할 때를 고려해 보겠습니다. HTML에서는 라디오 버튼 입력을 사용하며, 예를 들어 `<input type="radio" name="choice" value="option1" />`와 같은 형식을 사용합니다. 각 선택사항은 고유한 입력 요소로 표현됩니다. 이는 나에게 이상적이지 않다고 느껴집니다. 대부분의 경우, 라디오 버튼은 동일한 이름에 영향을 미치도록 함께 그룹화됩니다. HTML 접근 방식은 많은 보일러플레이트(각 선택에 대한 `type="radio"` 및 `name="choice"`의 중복)를 야기합니다. 또한, 데스크탑의 라디오 버튼과는 달리, 모바일 운영 체제는 단일 옵션을 선택하기 위한 강력한 표준 UI를 제공하지 않습니다. 대부분의 모바일 앱은 이러한 상호작용을 위해 더 풍부하고 사용자 정의된 UI를 사용합니다. 그래서 HXML에서는 `<select-single>`이라는 요소를 사용하여 이 UI를 구현합니다:

#figure(caption: [Select-single 요소])[ ```xml
<select-single name="choice"> <1>
  <option value="option1"> <2>
    <text>Option 1</text> <3>
  </option>
  <option value="option2">
    <text>Option 2</text>
  </option>
</select-single>
``` ]
1. 하나의 선택을 선택할 수 있는 요소. 선택의 이름은 여기서 한 번 정의됩니다.
2. 선택사항 중 하나를 나타내는 요소. 선택 값은 여기서 정의됩니다.
3. 선택의 UI. 이 예제에서는 텍스트를 사용하지만, UI 요소 중 어떤 것이든 사용할 수 있습니다.

#index[HXML][\<select-single\>]
`<select-single>` 요소는 여러 개의 선택 사항 중 하나를 선택하는 입력의 상위 요소입니다. 이 요소는 선택된 선택의 직렬화 시 사용되는 `name` 속성을 포함합니다. `<select-single>` 내의 `<option>` 요소는 사용 가능한 선택 사항을 나타냅니다. 각 `<option>` 요소에는 `value` 속성이 있습니다. 누르면 이는 입력의 선택된 값이 됩니다. `<option>` 요소는 또한 그 안에 다른 UI 요소를 포함할 수 있습니다. 따라서 우리는 입력을 라디오 버튼 목록이나 레이블로 제한받지 않고, 직관적인 UI 요소로 선택 옵션을 렌더링할 수 있습니다. HXML은 선택된 옵션을 강조하기 위해 눌림 및 선택 상태의 모디파이어를 지원합니다.

HXML의 입력의 모든 기능을 설명하는 것은 한 장을 차지할 것입니다. 대신, 몇 가지 다른 입력 요소와 그 기능을 요약하겠습니다.

#index[HXML][\<select-multiple\>]
#index[HXML][\<switch\>]
#index[HXML][\<date-field\>]- `<select-multiple>`은 `<select-single>`처럼 작동하지만, 여러 옵션을 켜고 끄는 것을 지원합니다. 이는 HTML의 체크박스 입력을 대체합니다. - `<switch>` 요소는 모바일 UI에서 일반적인 켜기/끄기 스위치를 렌더링합니다. - `<date-field>` 요소는 특정 날짜 입력을 지원하며, 형식 설정 매개변수 등을 위한 폭넓은 사용자 정의 기능이 제공됩니다.

#index[HXML][\<form\>]
#index[HXML][custom elements]
입력에 관해 언급할 두 가지 다른 사항이 있습니다. 첫 번째는 `<form>` 요소입니다. `<form>` 요소는 직렬화를 위한 입력을 그룹화하는 데 사용됩니다. 사용자가 백엔드 요청을 트리거하는 작업을 수행할 때, 하이퍼뷰 클라이언트는 주변의 `<form>` 내 모든 입력을 직렬화하고 요청에 포함시킵니다. 이는 `GET` 및 `POST` 요청 모두에 해당합니다. 이는 이후 장에서 행동에 대해 논의할 때 좀 더 자세히 다룰 것입니다. 이 장의 후반부에서 HXML의 사용자 정의 요소에 대한 지원에 대해서도 설명하겠습니다. 사용자 정의 요소를 통해 자신의 입력 요소를 생성할 수 있습니다. 사용자 정의 입력 요소는 복잡한 XML 구문으로 끔찍한 강력한 상호작용을 구축할 수 있게 하여 나머지 HXML과 잘 통합되도록 합니다.

==== 스타일링

#index[HXML][styling]
지금까지 HXML 요소에 스타일을 적용하는 방법에 대해 언급하지 않았습니다. 우리는 '헬로 월드(Hello World)' 앱에서 각 `<screen>`이 `<styles>` 요소를 포함할 수 있음을 보았습니다. '헬로 월드' 앱으로 돌아가서 `<styles>` 요소를 채워 보겠습니다.

#figure(
  caption: [UI 스타일링 예시],
)[ ```xml
<doc xmlns="https://hyperview.org/hyperview">
  <screen>
    <styles> <1>
      <style class="body" flex="1" flexDirection="column" /> <2>
      <style class="header"
        borderBottomWidth="1" borderBottomColor="#ccc" />
      <style class="main" margin="24" />
      <style class="h1" fontSize="32" />
      <style class="info" color="blue" />
    </styles>

    <body style="body"> <3>
      <header style="header">
        <text style="info">My first app</text>
      </header>
      <view style="main">
        <text style="h1 info">Hello World!</text> <4>
      </view>
    </body>
  </screen>
</doc>
``` ]
1. 화면의 모든 스타일을 포함하는 요소
2. "body"에 대한 스타일 클래스 정의 예시
3. UI 요소에 "body" 스타일 클래스를 적용
4. 요소에 여러 스타일 클래스(h1 및 info)를 적용하는 예시

HXML에서 스타일링은 CSS와 같은 별도의 언어를 사용하는 것이 아니라 XML 형식의 일부입니다. 하지만 CSS 규칙과 `<style>` 요소 간에 몇 가지 유사점을 찾을 수 있습니다. CSS 규칙은 선택자와 선언으로 구성됩니다. 현재 버전의 HXML에서는 사용 가능한 오직 한 선택자는 `class` 속성으로 표시되는 클래스 이름입니다. `<style>` 요소의 나머지 속성은 속성 및 속성 값을 구성하는 선언입니다.

`<screen>` 내의 UI 요소는 각각의 `<style>` 속성에 클래스 이름을 추가하여 `<style>` 규칙을 참조할 수 있습니다. "Hello World!" 주위의 `<text>` 요소는 `h1` 및 `info`라는 두 개의 스타일 클래스를 참조합니다. 해당 클래스에서 가져온 스타일은 요소에 나타나는 순서대로 서로 병합됩니다. 스타일 속성은 CSS의 속성과 유사합니다(색상, 여백/패딩, 경계 등). 현재 사용 가능한 레이아웃 엔진은 flexbox에 기반합니다.

스타일 규칙은 꽤 장황할 수 있습니다. 간결함을 위해, 이 장에서 필요한 경우를 제외하고 나머지 예제에서는 `<styles>` 요소를 포함하지 않겠습니다.

==== 사용자 정의 요소

#index[HXML][custom elements]
하이퍼뷰와 함께 제공되는 기본 UI 요소는 상당히 기본적입니다. 대부분의 모바일 앱은 훌륭한 사용자 경험을 제공하기 위해 더 풍부한 요소를 필요로 합니다. 다행히도 HXML은 구문에서 사용자 정의 요소를 쉽게 수용할 수 있습니다. HXML은 사실상 "확장 가능한 마크업 언어"라고도 불리는 XML에 불과합니다. 확장성은 이미 형식에 내장되어 있습니다! 개발자는 사용자 정의 요소를 나타내기 위해 새로운 요소와 속성을 자유롭게 정의할 수 있습니다.

구체적인 예로 "헬로 월드(Hello World)" 앱에 지도 요소를 추가하려고 한다고 가정해 보겠습니다. 우리는 지도가 정의된 영역을 표시하고 해당 영역의 특정 좌표에 하나 이상의 마커를 표시하기를 원합니다. 이러한 요구사항을 XML로 변환해 보겠습니다:
- `<area>` 요소는 지도가 표시하는 영역을 나타냅니다. 이 영역을 지정하기 위해, 요소는 영역의 중심을 위한 `latitude` 및 `longitude` 속성과 중앙의 +/- 표시 영역을 나타내는 `latitude-delta` 및 `longitude-delta` 속성을 포함할 것입니다.
- `<marker>` 요소는 해당 영역의 마커를 나타냅니다. 마커의 좌표는 마커의 `latitude` 및 `longitude` 속성으로 정의됩니다.

이러한 사용자 정의 XML 요소를 사용하면 앱의 지도 인스턴스는 다음과 같이 보일 수 있습니다:

#figure(
  caption: [HXML의 사용자 정의 요소],
)[ ```xml
<doc xmlns="https://hyperview.org/hyperview">
  <screen>
    <body>
      <view>
        <text>Hello World!</text>
        <area latitude="37.8270" longitude="122.4230"
          latitude-delta="0.1" longitude-delta="0.1"> <1>
          <marker latitude="37.8118" longitude="-122.4177" /> <2>
        </area>
      </view>
    </body>
  </screen>
</doc>
``` ]
1. 지도가 나타내는 영역을 나타내는 사용자 정의 요소
2. 특정 좌표에 표시된 마커를 나타내는 사용자 정의 요소

구문은 핵심 HXML 요소와 잘 어울립니다. 그러나 잠재적인 문제가 있습니다. "area"와 "marker"는 상당히 일반적인 이름입니다. `<area>` 및 `<marker>` 요소가 차트 및 그래프를 렌더링하는 사용자 정의에 의해 사용될 수 있습니다. 만약 우리의 앱이 지도가 있는 경우와 차트가 있는 경우, HXML 마크업은 모호하게 됩니다. `<area>` 또는 `<marker>`를 발견했을 때 클라이언트에게 무엇을 렌더링해야 할까요?

#index[Hyperview][XML namespaces]
여기서 XML 이름 공간이 사용됩니다. XML 이름 공간은 서로 다른 것을 나타내기 위해 사용되는 요소와 속성 간의 모호성을 제거합니다. `<doc>` 요소가 `https://hyperview.org/hyperview`가 전체 문서에 대한 기본 이름공간이라는 것을 선언하는 것을 기억하십시오. 다른 요소가 이름공간을 정의하지 않으므로, 위의 모든 요소는 `https://hyperview.org/hyperview` 이름공간의 일부입니다.

지도의 요소에 대한 새로운 이름공간을 정의해 보겠습니다. 이 이름공간은 문서의 기본값이 아니므로 요소에 접두사를 추가할 이름공간을 할당해야 합니다:

#figure[```xml
<doc xmlns="https://hyperview.org/hyperview"
  xmlns:map="https://mycompany.com/hyperview-map">
```]

이 새로운 속성은 `map:` 접두사가 "https://mycompany.com/hyperview-map" 이름공간과 연결되어 있다고 선언합니다. 이 이름공간은 무엇이든 될 수 있지만, 충돌을 피하는 고유한 것을 사용하는 것이 좋습니다. 회사/앱 도메인을 사용하는 것이 고유성을 보장하는 좋은 방법입니다. 이제 우리가 이름공간과 접두사를 가지고 있으므로 요소에 사용해 보겠습니다:

#figure(
  caption: [사용자 정의 요소의 이름공간 지정],
)[ ```xml
<doc xmlns="https://hyperview.org/hyperview"
  xmlns:map="https://mycompany.com/hyperview-map"> <1>
  <screen>
    <body>
      <view>
        <text>Hello World!</text>
        <map:area latitude="37.8270" longitude="122.4230"
          latitude-delta="0.1" longitude-delta="0.1"> <2>
          <map:marker latitude="37.8118" longitude="-122.4177" /> <3>
        </map:area> <4>
      </view>
    </body>
  </screen>
</doc>
``` ]
1. "map"으로 별칭을 붙인 이름공간 정의
2. "area" 시작 태그에 이름공간 추가
3. "marker" 셀프 클로징 태그에 이름공간 추가
4. "area" 종료 태그에 이름공간 추가

그게 전부입니다! 차트 라이브러리를 도입하면 "area" 및 "marker" 요소를 사용할 수 있습니다. 우리의 앱에서 지도와 차트를 모두 렌더링하도록 HXML 마크업에서 명확히 구분할 수 있습니다. 

이 시점에서 "하이퍼뷰 클라이언트는 어떻게 \<map:area\>를 포함한 문서를 렌더링하는지"에 대해 궁금할 수 있습니다. 실제로, 지금까지 사용자 정의 요소의 형식만 정의했지만, 앱의 기능으로 이 요소를 구현하지 않았습니다. 사용자 정의 요소를 구현하는 세부정보에 대해서는 다음 장에서 다룰 수 있도록 하겠습니다.

==== 행동 <_behaviors>

이전 장에서 논의한 바와 같이 HTML은 두 가지 기본 상호작용을 지원합니다:
- 하이퍼링크 클릭: 클라이언트는 GET 요청을 하고 응답을 새로운 웹 페이지로 렌더링합니다.
- 폼 제출: 클라이언트는(일반적으로) 폼의 직렬화된 내용을 가지고 POST 요청을 하고, 응답을 새로운 웹 페이지로 렌더링합니다.

하이퍼링크 클릭과 폼 제출은 간단한 웹 애플리케이션을 구축하기에 충분합니다. 그러나 이러한 두 가지 상호작용만 의존하다 보면 풍부한 UI를 구축하는 능력이 제한됩니다. 사용자가 특정 요소 위에 마우스를 올리거나, 또는 콘텐츠가 뷰포트로 스크롤될 때 일어나는 작업을 원한다고 가정해 보십시오. 기본 HTML로는 이를 수행할 수 없습니다. 또한 클릭과 폼 제출 모두 전체 새 웹 페이지를 로드해야 합니다. 현재 페이지의 일부만 업데이트하고 싶다고 가정해 보십시오. 이는 이전 웹 애플리케이션에서 흔히 발생하는 시나리오로, 사용자는 새 페이지로 이동하지 않고서도 내용을 가져오고 업데이트하길 기대합니다.

기본 HTML에서는 상호작용(클릭 및 제출)이 제한적이며 단일 동작(새 페이지 로딩)에 강하게 결합되어 있습니다. 물론 JavaScript를 사용하여 HTML을 확장하고 필요한 상호작용을 지원하는 새로운 구문을 추가할 수 있습니다. Htmx는 새로운 속성 세트를 사용하여 바로 그렇게 합니다:
- 상호작용은 링크와 폼뿐만 아니라 어떤 요소에도 추가할 수 있습니다.
- 상호작용은 클릭, 제출, 마우스 오버 또는 기타 호출 JavaScript 이벤트를 통해 트리거될 수 있습니다.
- 트리거의 결과로 발생하는 액션은 새로운 페이지 요청 뿐만 아니라 현재 페이지를 수정할 수도 있습니다.

htmx는 요소, 트리거 및 액션을 분리하여, HTML 구문 및 서버 측 웹 개발과 조화를 이루는 방식으로 풍부한 하이퍼미디어 기반 응용 프로그램을 구축할 수 있게 합니다.

#index[HXML][behaviors]
HXML은 트리거 및 액션을 통한 상호작용 정의 아이디어를 사양에 통합합니다. 이러한 상호작용을 "행동"이라고 부릅니다. 행동을 정의하기 위해 특별한 `<behavior>` 요소를 사용합니다. 다음은 새 모바일 화면을 내비게이션 스택에 푸시하는 간단한 행동의 예입니다:

#figure(caption: [기본 행동])[ ```xml
<text>
  <behavior <1>
    trigger="press" <2>
    action="push" <3>
    href="/next-screen" <4>
  />
  Press me!
</text>
``` ]
1. 부모 `<text>` 요소에서 상호작용을 캡슐화하는 요소.
2. 상호작용을 실행할 트리거, 이 경우 `<text>` 요소를 눌렀을 때.
3. 트리거될 때 실행될 액션, 이 경우 새로운 화면을 현재 스택에 푸시하기.
4. 새 화면에서 로드할 href.

이 예제에서 발생하는 일을 나누어 살펴봅시다. 먼저 "Press me!"라는 콘텐츠를 가진 `<text>` 요소가 있습니다. 우리는 앞서 HXML 예제에서 `<text>` 요소를 보여주었기 때문에 이는 새로운 것이 아닙니다. 그러나 현재 `<text>` 요소에는 새로운 자식 요소인 `<behavior>`가 포함되어 있습니다. 이 `<behavior>` 요소는 부모 `<text>` 요소에서 상호작용을 정의합니다. 두 개의 속성이 필요합니다:
- `trigger`: 행동을 발생시키는 사용자 동작 정의
- `action`: 트리거되었을 때 발생할 일 정의

이 경우 `trigger`는 `press`로 설정되어 있으므로, 사용자가 `<text>` 요소를 누를 때 이 상호작용이 발생합니다. `action` 속성은 `push`로 설정됩니다. `push`는 현재 내비게이션 스택에 새 화면을 푸시하는 액션입니다. 마지막으로 하이퍼뷰는 새로 푸시된 화면에서 어떤 콘텐츠를 로드해야 할지를 알아야 합니다. 여기서 `href` 속성이 필요합니다. 전체 URL을 정의할 필요는 없음을 주목하십시오. HTML과 마찬가지로, `href`는 절대적이거나 상대적인 URL일 수 있습니다.

이처럼 HXML의 `<behavior>`에 대한 첫 번째 예제입니다. 이 구문이 꽤 장황하게 보일 수도 있습니다. 실제로, 새 화면으로 내비게이트하기 위해 요소를 누르는 것은 모바일 앱에서 가장 일반적인 상호작용 중 하나입니다. 일반적인 경우에 대해 더 간단한 구문이 있으면 좋겠죠. 다행히도 `trigger`와 `action` 속성은 각각 `press`와 `push`의 기본 값을 가지고 있습니다. 따라서 구문을 작성하는 데 생략할 수 있습니다:

#figure(caption: [기본 행동의 기본값])[ ```xml
<text>
  <behavior href="/next-screen" /> <1>
  Press me!
</text>
``` ]

1. 눌렀을 때 이 행동은 주어진 URL로 새 화면을 엽니다.

이 `<behavior>` 마크업은 앞서 언급한 상호작용을 생성합니다. 기본 속성을 사용하여 `<behavior>` 요소는 HTML에서의 앵커 `<a>`와 유사하게 보입니다. 그러나 완전한 구문은 요소, 트리거 및 액션을 분리하는 우리의 목표를 달성합니다:
- 행동은 어떤 요소에도 추가할 수 있으며, 링크와 폼으로만 제한되지 않습니다.
- 행동은 클릭이나 폼 제출뿐만 아니라 명시적인 `trigger`를 지정할 수 있습니다.
- 행동은 명시적인 `action`을 지정할 수 있으며, 단순히 새 페이지 요청만으로 제한되지 않습니다.
- `href`와 같은 추가 속성은 액션에 더 많은 컨텍스트를 제공합니다.

특정 `<behavior>` 요소를 사용하는 것은 단일 요소가 여러 행동을 정의할 수 있게 해주며, 이를 통해 같은 트리거에서 여러 액션을 실행하거나, 같은 요소의 다른 트리거에서 서로 다른 액션을 실행할 수 있습니다. 이 장의 끝에서는 여러 행동의 힘을 보여주는 예제를 다룰 것입니다. 먼저 지원되는 액션과 트리거의 다양성을 보여줄 필요가 있습니다.

===== 액션

#index[HXML][behavior actions]
하이퍼뷰의 액션은 네 가지 일반 범주로 나누어집니다:
- 내비게이션 액션: 새로운 화면을 로드하고 화면 간 전환
- 업데이트 액션: 현재 화면의 HXML 수정
- 시스템 액션: OS 수준의 기능과 상호 작용
- 사용자 정의 액션: 클라이언트에서 추가한 코드를 실행할 수 있습니다.

====== 내비게이션 액션

#index[HXML][navigation actions]
가장 간단한 유형의 액션인 `push`를 이미 보았습니다. 우리는 `push`를 "내비게이션 액션"으로 분류하는데, 이는 모바일 앱에서 스크린 간 내비게이션과 관련된 것이기 때문입니다. 내비게이션 스택에 화면을 푸시하는 것은 하이퍼뷰에서 지원되는 여러 내비게이션 액션 중 하나일 뿐입니다. 사용자들은 또한 이전 화면으로 돌아가야 하고, 모달을 열고 닫거나, 탭 간 전환을 하거나, 임의의 화면으로 점프할 수 있어야 합니다. 이러한 내비게이션 각 유형은 `action` 속성의 서로 다른 값을 통해 지원됩니다:
- `push`: 현재 내비게이션 스택에 새로운 화면을 푸시합니다. 이는 현재 화면 위로 오른쪽에서 들어오는 화면처럼 보입니다.
- `new`: 모달로서 새로운 내비게이션 스택을 엽니다. 이는 현재 화면 위로 아래에서 들어오는 화면처럼 보입니다.
- `back`: 이는 `push` 액션의 보완입니다. 이는 현재 화면을 내비게이션 스택에서 팝하여(오른쪽으로 슬라이드) 제거합니다.
- `close`: 이는 `new` 액션의 보완입니다. 이는 현재 내비게이션 스택을 닫습니다(아래로 슬라이드).
- `reload`: 브라우저의 "새로 고침" 버튼과 유사하게, 현재 화면의 콘텐츠를 다시 요청합니다.
- `navigate`: 이 액션은 앱 내에서 주어진 `href`가 이미 로드된 화면을 찾으려고 시도합니다. 화면이 존재하면, 앱은 그 화면으로 이동합니다. 존재하지 않으면 `push`와 동일하게 작동합니다.

`push`, `new`, 및 `navigate`는 모두 새로운 화면을 로드합니다. 따라서, 하이퍼뷰는 새로운 화면을 위한 콘텐츠를 요청할 수 있도록 `href` 속성이 필요합니다. `back` 및 `close`는 새 화면을 로드하지 않으므로 `href` 속성이 필요하지 않습니다. `reload`는 흥미로운 경우입니다. 기본적으로, 현재 화면의 URL을 사용하여 콘텐츠를 다시 요청하는 데 사용됩니다. 그러나 다른 화면으로 교체하고 싶다면, 행동 요소에서 `reload`에 `href` 속성을 제공할 수 있습니다.

하나의 화면에서 여러 내비게이션 액션을 사용하는 "위젯" 앱의 예를 살펴보겠습니다:

#figure(caption: [내비게이션 액션 예시])[ ```xml
<screen>
  <body>
    <header>
      <text>
        <behavior action="back" /> <1>
        Back
      </text>

      <text>
        <behavior action="new" href="/widgets/new" /> <2>
        New Widget
      </text>
    </header>
    <text>
      <behavior action="reload" /> <3>
      Check for new widgets
    </text>
    <list>
      <item key="widget1">
        <behavior action="push" href="/widgets/1" /> <4>
      </item>
    </list>
  </body>
</screen>
``` ]
1. 이전 화면으로 사용자를 이동시킵니다.
2. 위젯을 추가하기 위해 새로운 모달을 엽니다.
3. 화면의 콘텐츠를 새로 고쳐서 백엔드에서 새로운 위젯을 표시합니다.
4. 특정 위젯의 세부정보가 포함된 새 화면을 푸시합니다.

앱의 대부분 화면에는 사용자가 이전 화면으로 돌아갈 방법이 필요합니다. 이는 일반적으로 화면이 어떻게 열렸는지에 따라 "back" 또는 "close" 액션의 버튼으로 제공됩니다. 이 예제에서는 위젯 스크린이 내비게이션 스택에 푸시되었기 때문에, "back" 액션이 적절합니다. 헤더에는 사용자가 새로운 위젯에 대한 데이터를 입력할 수 있는 두 번째 버튼이 있습니다. 이 버튼을 누르면 "New Widget" 스크린을 여는 모달이 열릴 것입니다. 이 "New Widget" 스크린은 모달로 열리므로, 스스로를 해제하고 다시 "widgets" 스크린을 표시하기 위해 해당 "close" 액션이 필요합니다. 마지막으로, 특정 위젯에 대한 더 많은 세부정보를 보려면, 각 `<item>` 요소는 "push" 액션이 포함된 행동을 포함합니다. 이 액션은 현재 내비게이션 스택에 "Widget Detail" 스크린을 푸시합니다. "Widgets" 스크린과 마찬가지로 "Widget Detail"에는 사용자가 돌아갈 수 있도록 "back" 액션을 사용하는 버튼이 필요합니다.

웹에서는 브라우저가 뒤로/앞으로 이동, 현재 페이지 새로 고침 또는 북마크로 이동하는 등의 기본 내비게이션 요구를 처리합니다. iOS와 Android는 네이티브 모바일 앱용으로 이러한 유형의 보편적인 내비게이션을 제공하지 않습니다. 앱 개발자가 스스로 처리해야 합니다. HXML의 내비게이션 액션은 개발자가 자신의 앱에 맞는 아키텍처를 구축할 수 있게 해주는 쉽고 강력한 방법을 제공합니다.

====== 업데이트 액션

#index[HXML][update actions]
행동 액션은 단순히 화면 간의 내비게이션에 제한되지 않습니다. 현재 화면의콘텐츠를 변경하는 데도 사용될 수 있습니다. 우리는 이러한 것을 "업데이트 액션"이라고 부릅니다. 내비게이션 액션과 마찬가지로, 업데이트 액션은 백엔드에 요청을 합니다. 그러나 응답은 전체 HXML 문서가 아니라 HXML의 조각입니다. 이 조각은 현재 화면의 HXML에 추가되어 UI 업데이트를 결과로 냅니다. `<behavior>`의 `action` 속성은 조각이 HXML에 통합되는 방식을 결정합니다. 또한, 기존 문서 내 조각이 통합되는 위치를 정의하기 위한 `target`이라는 새로운 속성을 `<behavior>`에 도입해야 합니다. `target` 속성은 화면의 올바른 요소에 대한 ID 참조입니다.

하이퍼뷰는 화면에 조각을 통합하는 다양한 방식을 나타내는 다음의 업데이트 액션을 지원합니다:
- `replace`: 조각으로 대상 요소를 전체적으로 교체합니다.
- `replace-inner`: 대상 요소의 자식 요소를 조각으로 교체합니다.
- `append`: 대상 요소의 마지막 자식 뒤에 조각을 추가합니다.
- `prepend`: 대상 요소의 첫 번째 자식 앞에 조각을 추가합니다.

더 구체적으로 하겠습니다. 이 예제에서 우리의 백엔드는 `/fragment`에 대한 `GET` 요청을 받고, 응답은 HXML 조각으로 나타납니다 `<text>My fragment</text>`입니다.

#figure(
  caption: [업데이트 액션 예시],
)[ ```xml
<screen>
  <body>
    <text>
      <behavior action="replace" href="/fragment" target="area1" /> <1>
      Replace
    </text>
    <view id="area1">
      <text>Existing content</text>
    </view>

    <text>
      <behavior action="replace-inner"
        href="/fragment" target="area2" /> <2>
      Replace-inner
    </text>
    <view id="area2">
      <text>Existing content</text>
    </view>

    <text>
      <behavior action="append" href="/fragment" target="area3" /> <3>
      Append
    </text>
    <view id="area3">
      <text>Existing content</text>
    </view>

    <text>
      <behavior action="prepend" href="/fragment" target="area4" /> <4>
      Prepend
    </text>
    <view id="area4">
      <text>Existing content</text>
    </view>

  </body>
</screen>
``` ]
1. 가져온 조각으로 area1 요소를 교체합니다.
2. area2의 하위 요소를 가져온 조각으로 교체합니다.
3. area3에 가져온 조각을 추가합니다.
4. area4의 첫 번째 자식 앞에 가져온 조각을 추가합니다.

이 예제에서는 네 가지 버튼이 각 업데이트 액션에 해당하며 `replace`, `replace-inner`, `append`, `prepend`입니다. 각 버튼 아래에는 해당 버튼에 해당하는 `<view>` 요소가 있습니다. 각 뷰의 `id`는 해당 버튼의 행동에 있는 `target`과 일치합니다.

사용자가 첫 번째 버튼을 누르면, 하이퍼뷰 클라이언트는 `/fragment`에 대한 요청을 합니다. 그런 다음 `id`가 "area1"인 요소를 찾고, 마지막으로 `<view id="area1">` 요소를 가져온 조각 `<text>My fragment</text>`로 교체합니다. 기존 뷰와 그 안에 포함된 텍스트는 교체됩니다. 사용자에게는 "기존 콘텐츠"가 "내 조각"으로 변경된 것처럼 보입니다. HXML에서 `<view id="area1">` 요소를 잃겠지요.

두 번째 버튼은 첫 번째와 유사하게 동작합니다. 그러나 `replace-inner` 액션은 대상 요소를 제거하지 않고 부모 요소를 그대로 남겨두고 내부 자식 요소만 교체합니다. 따라서 결과 마크업은 `<view id="area2"><text>My fragment</text></view>`처럼 보입니다.

세 번째와 네 번째 버튼은 화면에서 콘텐츠를 제거하지 않습니다. 대신 조각이 대상 요소의 하위에 추가됩니다(세 번째는 `append`, 네 번째는 `prepend`).

완전함을 위해, 사용자가 네 가지 버튼을 모두 누른 후의 화면 상태를 살펴보겠습니다:

#figure(
  caption: [업데이트 액션, 버튼을 누른 후],
)[ ```xml
<screen>
  <body>
    <text>
      <behavior action="replace" href="/fragment" target="area1" /> <1>
      Replace
    </text>
    <text>My fragment</text>

    <text>
      <behavior action="replace-inner"
        href="/fragment" target="area2" /> <2>
      Replace-inner
    </text>
    <view id="area2">
      <text>My fragment</text>
    </view>

    <text>
      <behavior action="append" href="/fragment" target="area3" /> <3>
      Append
    </text>
    <view id="area3">
      <text>Existing content</text>
      <text>My fragment</text>
    </view>

    <text>
      <behavior action="prepend" href="/fragment" target="area4" /> <4>
      Prepend
    </text>
    <view id="area4">
      <text>My fragment</text>
      <text>Existing content</text>
    </view>

  </body>
</screen>
``` ]
1. `replace` 액션을 사용하여 조각이 타겟을 완전히 교체합니다.
2. 조각이 타겟의 자식을 사용하는 `replace-inner` 액션으로 교체되었습니다.
3. 조각이 타겟의 마지막 자식에 추가됩니다.
4. 조각이 타겟의 첫 번째 자식 앞에 추가됩니다.

위의 예제에서 업데이트 액션은 백엔드에서 새 콘텐츠를 가져오고 화면에 추가하도록 요구합니다. 그러나 때로는 기존 요소의 상태를 변경하고 싶을 수 있습니다. 요소의 상태를 변경하는 가장 일반적인 것은 가시성입니다. 하이퍼뷰는 가시성을 변경할 수 있는 `hide`, `show`, 그리고 `toggle` 액션이 있습니다. 다른 업데이트 액션과 마찬가지로, `hide`, `show`, `toggle`은 현재 화면의 요소에 적용할 `target` 속성을 사용합니다.

#figure(caption: [Show, hide, and toggle actions])[ ```xml
<screen>
  <body>
    <text>
      <behavior action="hide" target="area" /> <1>
      Hide
    </text>

    <text>
      <behavior action="show" target="area" /> <2>
      Show
    </text>

    <text>
      <behavior action="toggle" target="area" /> <3>
      Toggle
    </text>

    <view id="area"> <4>
      <text>My fragment</text>
    </view>
  </body>
</screen>
``` ]
1. ID가 "area"인 요소를 숨깁니다.
2. ID가 "area"인 요소를 표시합니다.
3. ID가 "area"인 요소의 가시성을 전환합니다.
4. 액션의 타겟 요소입니다.

이 예제에서 "Hide", "Show", "Toggle"이라는 세 버튼은 "area"라는 `<view>`의 표시 상태를 수정합니다. "Hide"를 여러 번 눌러도 뷰가 숨겨지면 더 이상 영향을 받지 않습니다. 마찬가지로 "Show"를 여러 번 눌러도 뷰가 표시되면 영향을 받지 않습니다. "Toggle"을 누르면 보이기와 숨기기를 계속 전환할 것입니다.

하이퍼뷰는 기존 HXML을 수정하는 다른 액션도 포함합니다. 우리는 이를 자세히 다루지 않을 것이지만, 간단히 언급하겠습니다:
- `set-value`: 이 액션은 `<text-field>`, `<switch>`, `<select-single>` 등의 입력 요소의 값을 설정할 수 있습니다.
- `select-all` 및 `unselect-all`은 `<select-multiple>` 요소에서 모든 옵션을 선택/해제합니다.

====== 시스템 액션

#index[Hyperview][system actions]
일부 표준 하이퍼뷰 액션은 HXML과 상호작용하지 않습니다. 대신, 모바일 OS에서 제공하는 기능을 노출합니다. 예를 들어, Android와 iOS 모두 시스템 수준의 "공유(Share)" UI를 지원합니다. 이 UI는 한 앱에서 다른 앱으로 URL과 메시지를 공유를 허용합니다. 하이퍼뷰에는 이 상호작용을 지원하기 위한 `share` 액션이 있습니다. 사용자 지정 이름공간 및 공유 전용 속성이 포함됩니다.

#figure(caption: [시스템 공유 액션])[ ```xml
<behavior
  xmlns:share="https://instawork.com/hyperview-share" <1>
  trigger="press"
  action="share" <2>
  share:url="https://www.instawork.com" <3>
  share:message="Check out this website!" <4>
/>
``` ]
1. 공유 액션에 대한 이름공간 정의.
2. 이 행동의 액션은 공유 시트를 호출합니다.
3. 공유할 URL.
4. 공유할 메시지.

우리는 사용자 정의 요소에 대해 이야기할 때 XML 이름공간을 보았습니다. 여기서는 `url` 및 `message` 속성에 대한 이름공간을 사용합니다. 이러한 속성 이름들은 일반적이며 다른 구성 요소 및 행동에 의해 사용될 가능성이 높으므로, 이름공간은 모호성을 보장합니다. 누르면 "공유" 액션이 트리거됩니다. `url` 및 `message` 속성의 값은 시스템 공유 UI에 전달됩니다. 사용자는 그곳에서 SMS, 이메일 또는 기타 통신 앱을 통해 URL 및 메시지를 공유할 수 있습니다.

`share` 액션은 행동 액션이 사용자 지정 속성을 사용하여 추가 데이터를 전달하는 방법을 보여줍니다. 그러나 일부 액션은 훨씬 더 구조화된 데이터가 필요합니다. 이러한 데이터는 `<behavior>` 내에서 자식 요소를 통해 제공됩니다. 하이퍼뷰는 이를 통해 `alert` 액션을 구현합니다. `alert` 액션은 사용자 정의 시스템 수준의 대화 상자를 보여줍니다. 이 대화 상자는 제목과 메시지 및 사용자 지정된 버튼에 대한 구성이 필요합니다. 각 버튼은 눌렸을 때 또 다른 행동을 트리거해야 합니다. 이러한 수준의 구성은 속성만으로 처리되지 않으므로, 각 버튼의 행동을 나타내기 위해 사용자 정의 자식 요소를 사용합니다.

#figure(
  caption: [시스템 알림 액션],
)[ ```xml
<behavior
  xmlns:alert="https://hyperview.org/hyperview-alert" <1>
  trigger="press"
  action="alert" <2>
  alert:title="Continue to next screen?" <3>
  alert:message=
    "Are you sure you want to navigateto the next screen?" <4>
>
  <alert:option alert:label="Continue"> <5>
    <behavior action="push" href="/next" /> <6>
  </alert:option>
  <alert:option alert:label="Cancel" /> <7>
</behavior>
``` ]
1. 알림 액션에 대한 이름공간 정의.
2. 이 행동의 액션은 시스템 대화 상자를 호출합니다.
3. 대화 상자의 제목.
4. 대화 상자의 내용.
5. 대화 상자에서 "계속" 옵션
6. "계속"을 누르면 내비게이션 스택에 새 스크린을 푸시합니다.
7. 대화 상자를 해제하는 "취소" 옵션.

`share` 행동과 마찬가지로, `alert`는 이름공간을 사용하여 일부 속성과 요소를 정의합니다. `<behavior>` 요소 자체에는 대화 상자를 위한 `title` 및 `message` 속성이 포함됩니다. 대화 상자의 버튼 옵션은 `<behavior>` 내에서 정의된 새로운 `<option>` 요소를 사용하여 포함됩니다. 각 `<option>` 요소에는 레이블이 있으며, 필요에 따라 `<behavior>`를 포함할 수 있습니다! 이러한 HXML의 구조는 시스템 대화상자가 `<behavior>`에 정의될 수 있는 모든 상호작용을 호출할 수 있습니다. 위의 예에서 "계속" 버튼을 누르면 새 화면이 열립니다. 그러나 업데이트 액션을 트리거하거나 공유 시트를 여는 것과 같은 다른 작업을 수행하는 것도 가능합니다. 하지만 실제 앱에서는 그렇게 하지는 마세요! 큰 힘에는 큰 책임이 따르기 때문입니다.

====== 사용자 정의 액션

#index[Hyperview][custom actions]
하이퍼뷰의 표준 내비게이션, 업데이트 및 시스템 액션으로 많은 모바일 UI를 구축할 수 있습니다. 하지만 표준 세트는 모바일 앱에 필요한 모든 상호작용을 커버하지 않을 수 있습니다. 다행히도 액션 시스템은 확장 가능합니다. 하이퍼뷰에 사용자 정의 요소를 추가하는 것과 마찬가지로, 사용자 정의행동 액션도 추가할 수 있습니다. 사용자 정의 액션은 추가 데이터를 전달하는 속성에 이름공간을 사용하여 `share` 및 `alert` 액션과 유사한 구문을 가집니다. 사용자 정의 액션은 현재 화면의 HXML에 완전하게 액세스할 수 있어 화면의 상태를 수정하거나 현재 화면에서 요소를 추가/제거할 수 있습니다. 다음 장에서 모바일 연락처 앱을 향상시키기 위해 사용자 정의 행동 액션을 생성할 것입니다.

===== 트리거

#index[Hyperview][triggers]
우리는 이미 요소에서 `press`라는 가장 간단한 유형의 트리거를 보았습니다. 하이퍼뷰는 모바일 앱에서 사용되는 많은 다른 일반 트리거를 지원합니다.

====== 롱-프레스 <_long_press>
프레스와 밀접하게 관련된 것은 롱-프레스입니다. `trigger="longPress"`가 있는 행동은 사용자가 요소를 눌러서 고정할 때 발생합니다. "롱-프레스" 상호작용은 종종 단축키 및 기능을 위해 사용됩니다. 때때로, 요소는 `press` 및 `longPress`에 대해 서로 다른 액션을 지원합니다. 이는 동일한 UI 요소에서 여러 `<behavior>` 요소를 사용하여 이루어집니다.

#figure(
  caption: [롱-프레스 트리거 예시],
)[ ```xml
<text>
  <behavior trigger="press" action="push" href="/next-screen" /> <1>
  <behavior trigger="longPress" <2>
    action="push" href="/secret-screen" />
  Press (or long-press) me!
</text>
``` ]
1. 일반적인 누름은 다음 화면을 엽니다.
2. 롱 프레스는 다른 화면을 엽니다.

이 예제에서 일반적인 버튼 클릭은 새 화면을 열고 `/next-screen`에서 콘텐츠를 요청합니다. 그러나 길게 누르면 `/secret-screen`에서 콘텐츠를 포함한 새 화면이 열립니다. 이는 간결함을 위한 비유적인 예제입니다. 더 나은 UX는 길게 누르면 단축키와 고급 옵션의 맥락 메뉴가 나타나는 것입니다. 이는 `action="alert"`를 사용하고 단축키가 있는 시스템 대화 상자를 열면 달성할 수 있습니다.

====== 로드 <_load>
가끔 화면이 로드되자마자 동작을 트리거하고 싶을 때가 있습니다. `trigger="load"`는 정확히 이를 수행합니다. 한 가지 사용 사례는 화면의 쉘을 빠르게 로드한 다음 두 번째 업데이트 동작으로 화면의 주요 콘텐츠를 채우는 것입니다.

#figure(
  caption: [로드 트리거 예제],
)[ ```xml
<body>
  <view>
    <text>내 앱</text>
    <view id="container"> <1>
      <behavior trigger="load" action="replace" href="/content"
        target="container"> <2>
      <text>로드하는 중...</text> <3>
    </view>
  </view>
</body>
``` ]
1. 실제 콘텐츠가 없는 컨테이너 요소
2. 컨테이너를 대체하기 위해 즉시 /content 요청을 발생시키는 동작
3. 콘텐츠가 가져와지고 대체될 때까지 나타나는 로딩 UI

이 예제에서 우리는 제목 ("내 앱")은 있지만 콘텐츠가 없는 화면을 로드합니다. 대신 우리는 "컨테이너"라는 ID를 가진 `<view>`와 "로드하는 중..."이라는 텍스트를 표시합니다. 이 화면이 로드되자마자 `trigger=load` 동작이 `replace` 액션을 발생시킵니다. 이는 `/content` 경로에서 콘텐츠를 요청하고 응답으로 컨테이너 뷰를 교체합니다.

====== 가시성 <_visible>
`load`와 달리, `visible` 트리거는 동작이 뷰포트에 스크롤 될 때만 동작을 실행합니다. `visible` 동작은 `<list>`의 `<item>` 요소에서 무한 스크롤 상호작용을 구현하는 데 일반적으로 사용됩니다. 목록의 마지막 항목에는 `trigger="visible"`이 있는 동작이 포함됩니다. `append` 동작은 다음 페이지의 항목을 가져와서 목록에 추가합니다.

====== 새로 고침 <_refresh>
이 트리거는 `<list>` 및 `<view>` 항목에서 "당겨서 새로 고침" 동작을 캡처합니다. 이 상호작용은 백엔드에서 최신 콘텐츠를 가져오는 것과 관련이 있습니다. 따라서 일반적으로 화면에 최신 데이터를 표시하기 위해 업데이트 또는 새로 고침 동작과 함께 사용됩니다.

#figure(caption: [당겨서 새로 고침 트리거 예제])[ ```xml
<body>
  <view scroll="true">
    <behavior trigger="refresh" action="reload" /> <1>
    <text>아직 항목이 없습니다</text>
  </view>
</body>
``` ]
1. 보기 화면을 새로 고침하기 위해 아래로 당겨졌을 때 새로 고침합니다.

`trigger="refresh"`를 `<view>` 또는 `<list>`에 추가하면 해당 요소에 당겨서 새로 고침 상호작용이 추가되며, 요소가 아래로 당겨질 때 스피너를 표시하는 것도 포함됩니다.

====== 포커스, 블러 및 변경 <_focus_blur_and_change>
이러한 트리거는 입력 요소와의 상호작용과 관련이 있습니다. 따라서 `focus` 및 `blur`는 사용자가 입력 요소에 포커스를 맞추고 흐림 현상을 초래할 때 각각 동작이 트리거됩니다. `change`는 사용자가 텍스트 필드에 문자를 입력할 때와 같이 입력 요소의 값이 변경될 때 트리거됩니다. 이러한 트리거는 종종 폼 필드에 대해 일부 서버 측 검증을 수행해야 하는 동작들과 함께 사용됩니다. 예를 들어, 사용자가 사용자 이름을 입력하고 필드에서 블러 처리하면, `blur`에서 백엔드에 요청을 보내 사용자 이름의 고유성을 확인하는 동작이 트리거될 수 있습니다. 입력된 사용자 이름이 유일하지 않으면, 응답에는 사용자가 다른 사용자 이름을 선택해야 한다는 오류 메시지가 포함될 수 있습니다.

===== 여러 동작 사용하기

#index[HXML][여러 동작]
위에서 보여준 대부분의 예제는 단일 `<behavior>`를 요소에 연결합니다. 그러나 Hyperview에는 그런 제한이 없습니다; 요소는 여러 동작을 정의할 수 있습니다. 우리는 이미 하나의 요소가 `press` 및 `longPress`에서 다른 동작이 트리거되는 예를 보았습니다. 그러나 우리는 또한 동일한 트리거에서 여러 동작을 트리거할 수 있습니다.

이 다소 비유적인 예제에서 우리는 "숨기기" 버튼을 눌렀을 때 화면에서 두 개의 요소를 숨기고자 합니다. 두 요소는 HXML에서 멀리 떨어져 있으며, 공통 조상 요소를 숨겨서는 숨길 수 없습니다. 하지만 우리는 두 개의 동작을 동시에 트리거할 수 있습니다. 각각은 "hide" 동작을 실행하지만 다른 요소를 타겟팅합니다.

#figure(caption: [버튼 클릭 시 여러 동작 트리거하기])[ ```xml
<screen>
  <body>
    <text id="area1">영역 1</text>

    <text>
      <behavior trigger="press" action="hide" target="area1" /> <1>
      <behavior trigger="press" action="hide" target="area2" /> <2>
      숨기기
    </text>

    <text id="area2">영역 2</text>
  </body>
</screen>
``` ]
1. 눌렀을 때 ID가 "area1"인 요소 숨기기.
2. 눌렀을 때 ID가 "area2"인 요소 숨기기.

Hyperview는 마크업에서 나타나는 순서대로 동작을 처리합니다. 이 경우 ID가 "area1"인 요소가 먼저 숨겨지고, 그 다음 ID가 "area2"인 요소가 숨겨집니다. "hide"는 순간적인 동작이기 때문에(즉, HTTP 요청을 하지 않음) 두 요소는 동시에 숨겨지는 것처럼 보입니다. 그러나 HTTP 요청의 응답에 의존하는 두 동작("replace-inner"와 같은)을 트리거했다면? 그런 경우, 각 개별 동작은 Hyperview가 HTTP 응답을 수신하자마자 처리됩니다. 네트워크 지연에 따라 두 동작은 어떤 순서로든 적용될 수 있으며, 동시에 적용될 것이라고 보장할 수 없습니다.

우리는 여러 동작이 있는 요소와 다른 트리거가 있는 요소를 보았습니다. 또한 우리는 동일한 트리거가 있는 여러 동작을 가진 요소를 보았습니다. 이러한 개념은 함께 혼합될 수 있습니다. 프로덕션 Hyperview 앱이 여러 동작을 포함하고, 일부는 함께 트리거되고 다른 일부는 다른 상호작용에서 트리거되는 것은 드문 일이 아닙니다. 사용자 정의 동작이 있는 여러 동작을 사용하면 HXML이 선언적으로 유지되며 기능을 희생하지 않습니다.

==== 요약 <_summary>
우리는 여기에서 많은 새로운 개념을 다루고 있으며, HXML에 대한 이 소개는 표면만 긁어모으고 있습니다. HXML에 대해 더 알아보려면 #link(
  "https://hyperview.org/docs/reference_index",
)[공식 참고 문서]를 참조하는 것이 좋습니다. 지금은 몇 가지 주요 요점을 가지고 가시길 바랍니다.

첫째, HXML은 HTML과 유사하게 보이고 느껴집니다. 서버 측 렌더링 프레임워크에 익숙한 웹 개발자는 HXML을 작성하기 위해 동일한 기술을 사용할 수 있습니다. 기본 UI 요소(`<view>`, `<text>`, `<image>`) 외에 HXML은 모바일 전용 UI를 구현하기 위한 요소를 명시합니다. 여기에는 레이아웃 패턴(`<screen>`, `<list>`, `<section-list>`) 및 입력 요소(`<switch>`, `<select-single>`, `<select-multiple>`)가 포함됩니다.

둘째, HXML에서의 상호작용은 동작을 사용하여 정의됩니다. htmx에서 영감을 받은 `<behavior>` 요소는 사용자 상호작용(트리거)과 결과 동작을 분리합니다. 동작에는 세 가지 주요 범주가 있습니다:
- 내비게이션 동작(`push`, `back`)은 모바일 앱의 화면 간 내비게이션을 가능하게 합니다.
- 업데이트 동작(`replace`, `append`)은 서버에서 요청된 새로운 HXML 조각으로 화면을 업데이트할 수 있게 합니다.
- 시스템 동작(`alert`, `share`)은 iOS 및 Android의 시스템 레벨 기능과 상호작용을 가능하게 합니다.

마지막으로, HXML 자체는 커스터마이즈를 위해 설계되었습니다. 개발자는 사용자 정의 요소와 사용자 정의 동작을 정의하여 그들의 앱과의 가능한 사용자 상호작용을 확장할 수 있습니다.

=== 하이퍼미디어, 모바일을 위하여 <_hypermedia_for_mobile>
모바일에서 하이퍼미디어 기반 애플리케이션에 대한 강력한 사례가 있습니다. 모바일 앱 플랫폼은 개발자를 두꺼운 클라이언트 아키텍처로 유도합니다. 그러나 두꺼운 클라이언트를 사용하는 앱은 웹의 SPA와 동일한 문제에 직면합니다. 모바일 앱에 하이퍼미디어 아키텍처를 사용하면 이러한 문제를 해결할 수 있습니다.

HXML이라는 새로운 형식을 기반으로 한 Hyperview는 여기에서 경로를 제공합니다. HXML을 렌더링하기 위해 오픈 소스 모바일 스릴 클라이언트를 제공합니다. HXML은 모바일 UI에 해당하는 요소와 패턴의 툴킷을 엽니다. 개발자는 그들의 앱의 요구 사항에 맞게 Hyperview를 발전시킬 수 있으면서 하이퍼미디어 아키텍처를 완전히 수용할 수 있습니다. 이는 승리입니다.

맞습니다, 하이퍼미디어는 모바일 앱에서도 작동할 수 있습니다. 다음 두 장에서는 Hyperview를 사용하여 Contact.app 웹 애플리케이션을 네이티브 모바일 앱으로 전환하는 방법을 보여주겠습니다.

#html-note(
  label: [하이퍼미디어 노트],
)[서버 측 강점을 극대화하세요][
  이 책의 Hyperview 섹션에서는 HTML을 사용하지 않기 때문에 HTML 특정 조언이나 생각을 제공하기보다는 하이퍼미디어에 대한 더 넓은 관찰을 하겠습니다.

  하이퍼미디어 기반 접근의 큰 장점은 웹 애플리케이션을 구축할 때 서버 측 환경이 훨씬 더 중요해진다는 것입니다. 단순히 JSON을 생성하는 대신, 백엔드는 하이퍼미디어 애플리케이션의 사용자 경험에서 중요한 구성 요소입니다.

  그렇기 때문에 거기에 있는 기능을 깊이 살펴보는 것이 의미가 있습니다. 예를 들어, 많은 오래된 웹 프레임워크는 HTML 생성과 관련하여 신뢰할 수 있는 깊은 기능을 가지고 있습니다. 서버 측 캐싱과 같은 기능은 매우 빠른 웹 애플리케이션과 느린 사용자 경험 간의 차이를 만들 수 있습니다.

  사용 가능한 모든 도구를 배우는 데 시간을 투자하세요.
  
  기본적으로 하이퍼미디어 기반 애플리케이션의 서버 응답은 100ms 이내에 완료되도록 하며, 성숙한 서버 측 프레임워크는 이를 가능하게 하는 도구를 제공합니다.

  서버 측 환경은 코드를 적절히 팩터링(또는 조직화)하기 위한 매우 성숙한 메커니즘을 가지고 있습니다. 대부분의 환경에서는 모델/뷰/컨트롤러 패턴이 잘 개발되어 있으며, 모듈, 패키지 등과 같은 도구가 코드 조직에 훌륭한 방법을 제공합니다.

  오늘날의 SPA 및 모바일 사용자 인터페이스가 일반적으로 컴포넌트를 통해 조직되는 반면, 하이퍼미디어 기반 애플리케이션은 일반적으로 템플릿 포함을 통해 조직되며, 서버 측 템플릿은 애플리케이션의 하이퍼미디어 렌더링 요구에 따라 나눠지고 필요에 따라 서로 포함됩니다. 이는 보통 컴포넌트 기반 애플리케이션에서 발견하는 것보다 더 작고 덩어리진 파일을 생성하는 경향이 있습니다.

  또 다른 기술은 템플릿 조각에 주목하는 것입니다. 이 기술을 사용하면 템플릿 파일의 일부만 렌더링할 수 있습니다. 이점은 서버 측 애플리케이션에 대한 템플릿 파일 수를 줄일 수 있습니다.

  관련된 팁은 데이터 저장소에 대한 직접적인 접근을 활용하는 것입니다. 두꺼운 클라이언트 접근을 사용하여 애플리케이션을 구축할 때 데이터 저장소는 일반적으로 데이터 API(JSON 등) 뒤에 존재합니다. 이러한 간접적인 수준은 프론트엔드 개발자가 데이터 저장소에서 사용할 수 있는 도구를 충분히 활용하는 것을 종종 방해합니다. 예를 들어, GraphQL은 이 문제를 해결하는 데 도움이 될 수 있지만, 많은 개발자들이 잘 이해하지 못하는 보안 관련 문제를 동반합니다.

  반면 서버 측에서 하이퍼미디어를 생성할 때, 하이퍼미디어를 생성하는 개발자는 데이터 저장소에 완전히 액세스할 수 있으며, 예를 들어 SQL 저장소의 조인 및 집계 기능을 활용할 수 있습니다.

  이러한 사실은 최종 하이퍼미디어를 생성하는 개발자에게 훨씬 더 표현력 있는 힘을 제공합니다. 하이퍼미디어 API는 UI 요구를 기준으로 구조화할 수 있으므로 각 엔드포인트를 데이터 저장소 요청 수를 최소화하도록 조정할 수 있습니다.

  기본적으로 모든 서버 요청은 세 번 이하의 데이터 저장소 접근을 목표로 해야 합니다. 이 규칙을 따르면, 하이퍼미디어 기반 애플리케이션은 매우 빠르게 작동할 것입니다.
]
